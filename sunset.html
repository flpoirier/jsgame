<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Sunset</title>
    <style>
      * { padding: 0; margin: 0; }
      canvas { display: block; margin: 0 auto; }
    </style>
  </head>
  <body>
    <canvas id="myCanvas" width="1100" height="750"></canvas>
    <script>
      var canvas = document.getElementById("myCanvas");
      var ctx = canvas.getContext("2d");
      var canvasWidth = 1100;
      var canvasHeight = 750;

      var sunRad = 20;
      var sunX = canvasWidth / 2;
      var sunY = sunRad;
      var sunset = 0;

      var bridgeX = canvasWidth / 2;
      var bridgeY = canvasHeight + 400;
      var bridgeRad = canvasWidth * 2/3;

      var dudeX = 40;
      var dudeHeight = 75;
      var dudeDx = 1;
      var walkSpeed = 2;

      var rightPressed = false;
      var leftPressed = false;
      var upPressed = false;
      var downPressed = false;
      var spacePressed = false;

      var jumping = false;
      var jumpHeight = 0;
      var jumpSpeed = 3;
      var maxJump = 80;

      var maxTime = 120;
      var time = maxTime;

      var gameStarting = true;
      var gameOver = false;

      function getRandomInt(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min)) + min;
      }

      function negOrPos() {
        let nums = [-1, 1];
        let idx = getRandomInt(0,2);
        return nums[idx];
      }

      function distance(x1, y1, x2, y2) {
        return Math.sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );
      }

      var stars = [];
      var twinkle = 0;
      var falling = 0;
      for (let star = 0; star < 800; star++) {
        let starX = getRandomInt(0, canvasWidth);
        let starY = getRandomInt(-canvasHeight, canvasHeight);
        let starRad = getRandomInt(1,3);
        let dX = getRandomInt(8,15) * negOrPos();
        let dY = getRandomInt(2,5) * negOrPos();
        stars.push({starX: starX, starY: starY, starRad: starRad, dX: dX, dY: dY});
      }

      var red = 85;
      var green = 200;
      var blue = 255;

      function skyColored(r, g) {
        let redDiff = Math.abs(red - r);
        let greenDiff = Math.abs(green - g);
        if (redDiff === 0 && greenDiff === 0) {
          return true;
        } else {
          return false;
        }
      }

      function draw() {

        sunset += 1;

        if (sunset === 5 && blue > 40) {
          red -= 1;
          green -= 2;
          blue -= 2;
          sunset = 0;
        }

        // if (sunY < (800)) {
          sunY += 1;
        // } // else {
        //   gameOver = true;
        // }

        ctx.fillStyle = `rgb(${red},${green},${blue})`;
        ctx.fillRect(0,0,canvasWidth,canvasHeight);
        //
        // ctx.fillStyle = "rgb(6,76,6)";
        // ctx.fillRect(0,400,900,200);

        // for (let x = (sunX - 150); x < (sunX + 150); x++) {
        //   for (let y = (sunY - 150); y < (sunY + 150); y++) {
        //     dist = Math.ceil(distance(sunX, sunY, x, y));
        //     ctx.fillStyle = `rgb(${red - dist + 150},${green},${blue})`;
        //     ctx.fillRect(x,y,1,1)
        //   }
        // }

        // for (let dist = 300; dist >= 0; dist--) {

        // ctx.fillStyle = "purple";
        // ctx.beginPath();
        // ctx.arc(sunX, sunY, 502, 0, 2 * Math.PI);
        // ctx.fill();
        if (blue < 150) {

          twinkle += 1;

          if (twinkle === 3 && !gameOver) {
            // for (let num = 0; num < 2; num++) {
              let idx = getRandomInt(0,stars.length);
              let star = stars[idx];
              if (star.starRad === 0) {
                star.starRad = 1;
              } else if (star.starRad === 1) {
                star.starRad = getRandomInt(0,3);
              } else if (star.starRad === 2) {
                star.starRad = 1;
              }

            // }
            twinkle = 0;
          }

          stars.forEach((star) => {
            // let stardist = distance(star[0],star[1],sunX, sunY);
            // ctx.fillStyle = `rgba(255,255,255,${stardist/1000})`;
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(star.starX, star.starY, star.starRad, 0, 2 * Math.PI);
            ctx.fill();
          });
        }

        let dist = 450;
        let tempRed = 255;
        let tempGreen = 255;
        let trans = 0.03;

        while (dist >= 0) {

          tempRed = red - dist + Math.floor(300*sunY/500);
          if (tempRed < red) {
            tempRed = red;
          }
          tempGreen = green - dist + Math.floor(175*sunY/500);
          if (tempGreen < green) {
            tempGreen = green;
          }
          // let tempBlue = blue + dist + Math.floor(200*sunY/500);
          // if (tempBlue < blue) {
          //   tempBlue = blue;
          // }
          if (!skyColored(tempRed, tempGreen)) {
            ctx.fillStyle = `rgba(${tempRed},${tempGreen},${blue}, ${trans})`;
            ctx.beginPath();
            ctx.arc(sunX, sunY, dist, 0, 2 * Math.PI);
            ctx.fill();
          }

          dist -= 3;
          if (trans < 1) {
            trans += 0.03;
          }
        }

        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(sunX, sunY, sunRad, 0, 2 * Math.PI);
        ctx.fill();

        // if (gameOver && twinkle > 500) {
        //   // stars[falling][1] += 15;
        //   // if (stars[falling][1] > canvasHeight + 5) {
        //   //   falling += 1;
        //   // }
        //   stars.forEach((star) => {
        //     // star.starX += star.dX;
        //     // star.starY += star.dY;
        //     if (star.starX > canvasWidth / 2) {
        //       star.starX -= 1;
        //     } else if (star.starX < canvasWidth / 2) {
        //       star.starX += 1;
        //     }
        //     if (star.starY > sunRad) {
        //       star.starY -= 1;
        //     } else if (star.starY < sunRad) {
        //       star.starY += 1;
        //     }
        //   });
        // }

        ctx.strokeStyle = "#7b9095";
        ctx.lineWidth = 15;
        ctx.beginPath();
        ctx.arc(bridgeX, bridgeY, bridgeRad, Math.PI, 2 * Math.PI)
        ctx.stroke();

        let translatedX = 0;
        if (dudeX < bridgeX) {
          translatedX = -(bridgeX - dudeX);
        } else if (dudeX > bridgeX) {
          translatedX = dudeX - bridgeX;
        }

        let dudeAngle = Math.PI - Math.acos(translatedX / bridgeRad);
        let dudeXDraw = dudeX;

        // change dudeX to account for jump

        // if (dudeX > Math.floor(canvasWidth / 2)) {
        //   dudeXDraw += jumpHeight;
        // } else if (dudeX < Math.floor(canvasWidth / 2)) {
        //   dudeXDraw -= jumpHeight;
        // }

        let dudeY = bridgeY - Math.floor(bridgeRad * Math.sin(dudeAngle)) - jumpHeight - 8;

        ctx.strokeStyle = "purple";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(dudeX, dudeY);
        ctx.lineTo(dudeX - dudeHeight * Math.cos(dudeAngle), dudeY - dudeHeight * Math.sin(dudeAngle));
        ctx.stroke();

        ctx.fillStyle = "#7b9095";
        ctx.font = "30px serif";
        ctx.fillText(`${timeString()}`, 40, 60);

        // if (gameStarting) {
        //   dudeX += dudeDx;
        // }

        // walking logic

        if (leftPressed) {
          dudeX -= walkSpeed;
        } else if (rightPressed) {
          dudeX += walkSpeed;
        }

        // boundaries on where avatar can walk

        if (dudeX > canvasWidth - 40) {
          dudeX = canvasWidth - 40;
          // starMove("right");
        } else if (dudeX < 40) {
          dudeX = 40;
          // starMove("left");
        }

        // jumping logic

        if (spacePressed) {
          jumping = true;
        }

        // if (jumping && jumpHeight < maxJump) {
        //   jumpHeight += jumpSpeed;
        // } else if (jumping && jumpHeight === maxJump) {
        //   jumping = false;
        // } else if (!jumping && jumpHeight > 0) {
        //   jumpHeight -= 2 * jumpSpeed;
        // }

        // jump height proportional to length of time space bar pressed

        if (spacePressed && jumpHeight < maxJump) {
          jumpHeight += jumpSpeed;
        } else if (!spacePressed && jumpHeight > 0) {
          jumpHeight -= 2 * jumpSpeed;
        }

      }

      // function starMove(direction) {
      //   if (direction === "left") {
      //     stars.forEach((star) => {
      //       star.starX -= 1;
      //       let translatedX = 0;
      //       if (star.starX < bridgeX) {
      //         translatedX = -(bridgeX - star.starX);
      //       } else if (star.starX > bridgeX) {
      //         translatedX = star.starX - bridgeX;
      //       }
      //       let starAngle = Math.PI - Math.acos(translatedX / bridgeRad);
      //       star.starY = bridgeY - Math.floor(bridgeRad * Math.sin(starAngle));
      //     });
      //   } else if (direction === "right") {
      //
      //   }
      // }

      function keyDownHandler(e) {
        if(e.keyCode == 39) {
          rightPressed = true;
        }
        else if(e.keyCode == 37) {
          leftPressed = true;
        }
        else if(e.keyCode == 38) {
          upPressed = true;
        }
        else if(e.keyCode == 40) {
          downPressed = true;
        }
        else if(e.keyCode == 32) {
          spacePressed = true;
        }
      }

      function keyUpHandler(e) {
        if(e.keyCode == 39) {
          rightPressed = false;
        }
        else if(e.keyCode == 37) {
          leftPressed = false;
        }
        else if(e.keyCode == 38) {
          upPressed = false;
        }
        else if(e.keyCode == 40) {
          downPressed = false;
        }
        else if(e.keyCode == 32) {
          spacePressed = false;
        }
      }

      function timeTick() {
        if (time > 0) {
          time -= 1;
        }
      }

      function timeString() {
        let mins = Math.floor(time / 60);
        let secs = time - (mins * 60);
        if (mins === 0) {
          mins = "00";
        } else {
          mins = `0${mins}`;
        }
        if (secs === 0) {
          secs = "00";
        } else if (secs < 10) {
          secs = `0${mins}`;
        } else {
          secs = `${secs}`;
        }
        return `${mins}:${secs}`;
      }

      document.addEventListener("keydown", keyDownHandler, false);
      document.addEventListener("keyup", keyUpHandler, false);
      setInterval(draw, 15);
      setInterval(timeTick, 1000);

    </script>
  </body>
</html>
